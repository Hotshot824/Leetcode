### [703. Kth Largest Element in a Stream]

---

### Binary Search

試著不使用 `std::priority_queue` 來解這題，那就用 Binary search 來進行 Insertion 的動作，並且在每次 Insertion 後，回傳第 `k` 大的元素。
-   但是實際 Runtime 上雖然也是 O(nlogn)，但是因為要做 vec.insert()，所以實際上比 `std::priority_queue` 還要慢
    -   `std::priority_queue` 的底層是用 Heap 來實作，也要做 Heapify 但是會比 `std::vector` 快
    -   `std::vector` Insertion 要重新分配記憶體，並且搬移資料，所以會比 Heapify 慢

Time Complexity O(nlogn), Space Complexity O(n).

**Solution:**
```go
class KthLargest {
private:
    std::vector<int> _vec;
    int _k = 0, _size = 0;

public:
    int add(int val) {
        int idx = this->searchIndex(val);
        this->_vec.insert(this->_vec.begin() + idx, val);
        this->_size++;

        idx = (this->_k > this->_size) ? 0 : this->_size - this->_k;
        return this->_vec[idx];
    }

    KthLargest(int k, std::vector<int>& nums) {
        this->_k = k;
        for (auto& x : nums) {
            this->add(x);
        }
    }

    int searchIndex(int val) {
        int left = 0, right = this->_size - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (val == this->_vec[mid]) {
                return mid;
            }
            if (val > this->_vec[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
```

[703. Kth Largest Element in a Stream]: https://leetcode.com/problems/kth-largest-element-in-a-stream