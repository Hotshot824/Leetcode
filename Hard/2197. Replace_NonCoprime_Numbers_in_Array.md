---
Category: Queue & Stack
Subcategory: Queue & Stack
Title: 2197. Replace Non-Coprime Numbers in Array
Date: 2025-09-16
Difficulty: Hard
Tag: Stack, Math
Status: Accepted
---

### [2197. Replace Non-Coprime Numbers in Array]

[2197. Replace Non-Coprime Numbers in Array]: https://leetcode.com/problems/replace-non-coprime-numbers-in-array

這題會給定一個數字陣列，對該陣列進行處理，規則如下:
1. 任何兩個相鄰的數字如果不是互質 (gcd > 1)，就將它們替換成它們的最小公倍數 (lcm)
2. 重複這個過程直到陣列中所有相鄰的數字都是互質的

**Example:**

1.  `[6,4,3,2,7,6,2]`
    -   `[6, 4]` is not coprime, replace with `lcm(6,4) = 12`
2.  `[12,3,2,7,6,2]`
    -   `[12, 3]` is not coprime, replace with `lcm(12,3) = 12`
3.  `[12,2,7,6,2]`
    -   `[12, 2]` is not coprime, replace with `lcm(12,2) = 12`
4.  `[12,7,6,2]`
    -   `[12, 7]` is coprime, move to next pair
5.  `[12,7,6]`
    -   `[7, 6]` is coprime, move to next pair
6.  `[12,7,6,2]`
    -   `[6, 2]` is not coprime, replace with `lcm(6,2) = 6`

`[12,7,6]` is the final result.

---

### Implementation

這題其實包含兩個主要概念:
1. 如何不停的檢查相鄰的數字
    -   使用 Stack 可以解決，每次檢查要推入的數字與 Stack 頂端的數字是否互質
2. 如何計算兩個數字的最小公倍數 (lcm) 和最大公因數 (gcd)
    -   GCD 可以使用[輾轉相除法 (Euclidean algorithm)] 計算
        -   `gcd(a, b) = gcd(b, a % b), until b == 0`
    -   LCM 可以使用公式 `lcm(a, b) = (a * b) / gcd(a, b)` 計算

> GCD(A, B), if the result bigger than 1, then A and B are not coprime.

[輾轉相除法 (Euclidean algorithm)]: https://en.wikipedia.org/wiki/Euclidean_algorithm


**Algorithm:**

1. 首先初始化 Stack 為空
2. 遍歷陣列中的每個數字 `n`
    -   設定 `lcm` 為 `n`
    -   當 Stack 不為空時，檢查 Stack 頂端的數字 `top` 與 `lcm` 的 GCD
        -   如果 GCD == 1，表示是互質，跳出迴圈
    -   計算 `lcm = (top * lcm) / gcd(top, lcm)`
    -   將 Stack 頂端的數字彈出
    -   繼續檢查新的 Stack 頂端
3. 將 `lcm` 推入 Stack
4. 最後 Stack 中的數字即為結果

-   Time Complexity O(N log M)
    -   N is the length of the array, M is the maximum number in the array. 
-   Space Complexity O(N).


**Go Solution:**
```go
func replaceNonCoprimes(nums []int) []int {
    stack := []int{}
    for _, n := range nums {
        lcm := n
        for len(stack) > 0 {
            top := stack[len(stack)-1]
            g := gcd(top, lcm)
            if g == 1 {
                break
            }
            lcm = (top * lcm) / g
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, lcm)
    }
    return stack
}

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

**CPP Solution:**
-   CPP 要注意 long long 的部分，因為 lcm 可能會超過 int 範圍
    -   用 `1LL` 轉型 long long 再做乘法計算
```cpp
class Solution {
public:
    vector<int> replaceNonCoprimes(vector<int>& nums) {
        std::vector<int> stk;
        for (auto num : nums) {
            int lcm = num;
            while (stk.size() > 0) {
                int top = stk[stk.size()-1];
                int g = gcd(top, lcm);

                if (g == 1) {
                    break;
                }

                long long tmp = 1LL * top * lcm;
                lcm = tmp / g;
                stk.pop_back();
            }
            stk.push_back(lcm);
        }

        return stk;
    }

    int gcd(int a, int b) {
        while(b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }
};
```