### [514. Freedom Trail]

這題我是先以 DFS 去搜尋所有可能的組合，來尋找使用最少次數的路徑，那麼首先要解決幾個問題:

-   假如是 Search 那就會有 CurrentState, NextState 如何計算這兩個狀態之間轉移需要的最少次數
    1.  使用一個 hash 來儲存所有字母間的 distance
    2.  因為這題是 ring 所以我們可以使用 index 來直接計算 distance
-   如何設計 DFS
    1.  終止條件是當 target 為空的時候
    2.  需要傳遞的參數: 當前狀態、剩餘的目標、圖表

這樣就能解這個問題了，但是速度很慢所以會 TLE，所以接下來要考慮一些加速方式:

![](https://leetcode.com/problems/freedom-trail/Figures/514/repeated_subproblems.png)

-   在這個題目中，我們有可能會遇到重複的子問題，所以如果我們使用的是 DFS 的話，我們可以使用 Memoization 來加速
    -   在上面的圖中我們可以發現除了 d<sub>2</sub>, d<sub>3</sub> 之外剩餘的子問題都是重複的
    -   所以如果使用的是 DFS 就有機會提前紀錄這些子問題的答案，這樣就可以避免重複計算

**DFS Solution:**
-   使用 Memoization 來加速 DFS 的運算
-   這裡要注意 Golang 中的 map 在參數傳遞的時候是傳址，即使不是使用 & 來傳遞
```go
var (
    memo = map[int]map[string]int{}
    lenght int
)

func findRotateSteps(ring string, key string) int {
    // Create an index map.
    alphabets := recordIndex(ring)
    lenght = len(ring)

    // Initialization memoization.
    memo = map[int]map[string]int{}
    for i := range ring {
        memo[i] = make(map[string]int)
    }

    return dfs(0, key, len(ring), alphabets)
}

func dfs(cur int, target string, alphabets map[byte][]int) int {
    if target == "" {
        return 0
    }

    if val, exists := memo[cur][target]; exists {
        return val
    }

    next := target[0]
    res := int(^uint(0) >> 1)
    for _, s := range alphabets[next] {
        distance := calculateDis(cur, s) + 1
        res = min(res, distance + dfs(s, target[1:], alphabets))
    }

    memo[cur][target] = res
    return res
}

func recordIndex(ring string) map[byte][]int {
    res := map[byte][]int{}
    for i := range ring {
        res[ring[i]] = append(res[ring[i]], i)
    }
    return res
}

func calculateDis(i, j int) int {
    clockwise := abs(i-j)
    counterclockwise := lenght - clockwise
    return min(clockwise, counterclockwise)
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

[514. Freedom Trail]: https://leetcode.com/problems/freedom-trail