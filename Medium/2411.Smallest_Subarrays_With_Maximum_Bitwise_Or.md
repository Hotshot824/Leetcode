---
Category: Greedy Algorithm
Subcategory: Greedy Algorithm
Title: 2411. Smallest Subarrays With Maximum Bitwise OR
Date: 2025-09-12
Difficulty: Medium
Status: Accepted
---
### [2411. Smallest Subarrays With Maximum Bitwise OR]

[2411. Smallest Subarrays With Maximum Bitwise OR]: https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/

這題是要在一個給定的陣列 `nums` 中找到 Index 限制為 `i<k` 的最大子陣列，
並回傳每個子陣列的長度。 

---

### Example:
```plaintext
Input: nums = [1,0,2,1,3],
Output: [3,3,2,2,1].
```

因為 nums[0] 向右找最多三個 index 就能找到最大 Bitwise OR，
nums[0] = `01` | `00` | `10` = `11 (3)`，所以 nums[0] 的結果是 3。

---

### Brute Force Solution:

第一個想法當然就直接用兩層迴圈去比較，找到每個元素的最大 Bitwise OR，
然後記錄下來每個元素的長度。

想當然然這樣的時間複雜度是 O(N<sup>2</sup>)，最後是 TLE。

**Golang:**
```go
func smallestSubarrays(nums []int) []int {
    res := make([]int, len(nums))
    for i := range res {
        res[i] = 1
    }

    for i := range nums {
        cur := nums[i]
        for j := i+1; j < len(nums); j++ {
            temp := cur | nums[j]
            if temp > cur {
                res[i] = j - i + 1
            }
            cur = temp
        }
    }
    return res
}
```

### Greedy Solution:

如果觀察題目會發現題目的 Index 限制是 `i < k`，也就是說每個元素的 Bitwise OR 都是從左邊開始累加，
我們可以去思考能不能紀錄當前的 `nums[i]` 還缺少幾個 bit 才能達到最大 Bitwise OR，
然後去紀錄最後一個缺少的 bit 的位置。

因此這樣要從後往前走訪，記錄一個 Int 大小的 `last`，紀錄每個 bit 的最後位置，
這樣就可以計算當前位址與缺失的 bit 的最大距離。

**Algorithm:**

Input: nums = [1,0,2,1,3]

1. 首先宣告一個 `last` 來紀錄每個 bit 的最後位置，這裡用 `[0, 0]` 取代。
2. 從後往前走訪 `nums`，對於每個 `nums[i]`，更新最後的 bit 位置。
    -   nums[4] = 3, last = [4, 4] 因為 3 的二進位是 `11`，所以要更新兩個 bit 的最後位置。
3. 計算當前位置與 `last` 的距離，是否有更遠的 Bit 可以使用。
    -   MaxLast = max(last[*], i), Distance = MaxLast - i + 1
4. 更新結果陣列 `res`，紀錄每個位置的最小子陣列長度。

**Step by Step:**
1. nums[4], last = [4, 4], res[4] = 4 - 4 + 1 = 1
2. nums[3], last = [4, 3], res[3] = 4 - 3 + 1 = 2
3. nums[2], last = [2, 3], res[2] = 3 - 2 + 1 = 2
4. nums[1], last = [2, 3], res[1] = 3 - 1 + 1 = 3
5. nums[0], last = [2, 0], res[0] = 3 - 0 + 1 = 3

Output: [3, 3, 2, 2, 1]

Golang:
```go
func smallestSubarrays(nums []int) []int {
    n := len(nums)
    res := make([]int, n)
    last := make([]int, 32)

    for i := 0; i < 32; i++ {
        last[i] = -1
    }

    for i := n - 1; i >= 0; i-- {
        for b := 0; b < 32; b++ {
            if (nums[i]>>b)&1 == 1 {
                last[b] = i
            }
        }

        maxPos := i
        for b := 0; b < 32; b++ {
            if last[b] > maxPos {
                maxPos = last[b]
            }
        }

        res[i] = maxPos - i + 1
    }

    return res
}
```

CPP:
```cpp
class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        int len = nums.size();
        std::vector<int> res(len, 1);
        std::array<int, 32> last;
        last.fill(-1);

        for (int i = len-1; i >= 0; i--) {
            for (int b = 0; b < 32; b++)
                if (nums[i]>>b&1 == 1) last[b] = i;

            int maxPos = i;
            
            for (int b = 0; b < 32; b++)
                if (last[b] > maxPos) maxPos = last[b];

            res[i] = maxPos - i + 1;
        }

        return res;
    }
};
```