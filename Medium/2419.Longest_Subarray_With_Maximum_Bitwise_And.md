---
Category: Bit Manipulation
Subcategory: Bit Manipulation
Title: 2419. Longest Subarray With Maximum Bitwise AND
Date: 2025-09-12
Difficulty: Medium
Status: Accepted
---
### [2419. Longest Subarray With Maximum Bitwise AND]

[2419. Longest Subarray With Maximum Bitwise AND]: https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/

2025/07/30 連續兩天的 Longest Subarray 題目，上次是 [2411. Smallest Subarrays With Maximum Bitwise OR] 但這次是 Bitwise AND，
這題是要在一個給定的陣列 `nums` 中找到 Index 限制為 `i<k` 並且所有元素的 Bitwise AND 為最大值的子陣列，
並回傳每個子陣列的長度。

[2411. Smallest Subarrays With Maximum Bitwise OR]: ./2411.Smallest_Subarrays_With_Maximum_Bitwise_OR.md

---

### Solution

AND 的解法比 OR 簡單很多，因為 AND 的最大值就是陣列中的最大值，反而用 OR Bitwise 的寫法來寫會比較複雜。
因此我們只需要找到每個元素的最大值，然後從左邊開始累加，直到遇到不是最大值的元素為止，
這樣就可以計算出每個元素的子陣列長度。

**CPP Solution:**
```cpp
class Solution {
public:
    int longestSubarray(std::vector<int>& nums) {
        int max_val = *std::max_element(nums.begin(), nums.end());
        int res = 0, count = 0;

        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == max_val) {
                count++;
                res = std::max(res, count);
            } else {
                count = 0;
            }
        }

        return res;
    }
};
```

這邊用了 `std::max_element` 來找到陣列中的最大值，其實可以更快在一次走訪就找到最大值和子陣列長度，
直接在走訪的時候就更新最大值和計數器。

**CPP Solution:**
```cpp
class Solution {
public:
    int longestSubarray(std::vector<int>& nums) {
        int max_val = nums[0];
        int count = 0, res = 0;

        for (int num : nums) {
            if (num > max_val) {
                max_val = num;
                count = 1;
                res = 1;
            } else if (num == max_val) {
                count++;
                res = std::max(res, count);
            } else {
                count = 0;
            }
        }

        return res;
    }
};
```