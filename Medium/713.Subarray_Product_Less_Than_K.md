### [713. Subarray Product Less Than K]

這題可以用 Sliding windows 來解，先思考以下部分:
1.  left 在什麼情況下要往前移動，移動後要做什麼
    -   如果有一個 pro 可以記錄 Sliding windows 內的乘積，當 pro >= k 時，left 要往前移動，並且更新 pro /= nums[left]
2.  如何計算 Sliding windows 內的 subarray 數量

這裡以 `[10, 5, 2, 6], k = 100` 為例，假如使用 tow point:
1.  left = 0, right = 0, pro = 10
    -   subarray `[10]`，cut = 1
2.  left = 0, right = 1, pro = 50
    -   subarray `[5], [10, 5]`，cut = 3
3.  left = 0, right = 2, pro = 100
    -   current subarray `[10, 5, 2]`, move left to 1, pro = 10
4.  left = 1, right = 2, pro = 10
    -   subarray `[2], [5, 2]`，cut = 5
5.  left = 1, right = 3, pro = 60
    -   subarray `[6], [2, 6], [5, 2, 6]`，cut = 8

可以觀察到，每次加入新的 j 時，就會新增 `j - i + 1` 個 subarray，所以只要以把這個新增的數量累加起來就能得到所有的 subarray。

---

Alogrithm:
1.  Using a var to record the product of the subarray.
2.  Using tow pointers to record the start and end of the subarray.
3.  Right pointer iterate the array.
    -   Update the product of the subarray.
    -   If the product is greater than or equal to k, move the left pointer to the right until the product is less than k.
4.  Count the subarray to the result.
5.  All elements are iterated, return the result.

Solution:
-   If k == 0, return 0.
    -   Because the problem constraint is `1 <= nums[i] <= 1000`, so the product of any subarray will not be 0.
```go
func numSubarrayProductLessThanK(nums []int, k int) int {
    if k == 0 {
        return 0
    }
    cnt, pro := 0, 1
    for i, j := 0, 0; j < len(nums); j++ {
        pro *= nums[j]
        for i <= j && pro >= k {
            pro /= nums[i]
            i++
        }
        cnt += j - i + 1;
    }
    return cnt
}
```

[713. Subarray Product Less Than K]: https://leetcode.com/problems/subarray-product-less-than-k