### [131. Palindrome Partitioning]

There are two key issues with this problem:
1. There are different cutting methods. `"aab" -> "a", "ab" | "aa", "b" | "aab"`
2. Judgment palindrome.

The cut problem is similar to the combinatorial problem:

as above diagram:
1. horizontal: First cut position.
2. verical: Remaining paragraphs after the last cut.

If the cutting line reaches the end, it means that a method to complete the cutting has been found.
-	[reference]

An Example for "abb"
-	remained "abb".
	-	"a" is palindrome, so cut "a" and remaining "ab" to recursive.
	-	"ab", "abb" is not palindrome
-	remained "bb"
	-	"b" is palindrome, so cut "b" and remaining "b" to recursive.
	-	"bb" is palindrome, so cut "bb" and remaining "" to recursive.
-	"abb" -> ["a", "b", "b"], ["a", "bb"].

![](/_image/131.palindrome-partitioning/1.jpg)

**Solution:** 
```go
var (
	substrings [][]string
	path       []string
)

func partition(s string) [][]string {
	substrings, path = [][]string{}, []string{}
	backtracking(s)
	return substrings
}

func backtracking(s string) {
	if len(s) <= 0 {
		tmp := append([]string{}, path...)
		substrings = append(substrings, tmp)
		return
	}
	for i := 1; i <= len(s); i++ {
		// s[:i] mean cut position, s[i:] is remaining paragraphs.
		if isPalindrome(s[:i]) {
			path = append(path, s[:i])
			backtracking(s[i:])
			path = path[:len(path)-1]
		}
	}
}

func isPalindrome(s string) bool {
	for i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {
		if s[i] != s[j] {
			return false
		}
	}
	return true
}
```

### Index Partition

**Solution**
```go
var (
	result [][]string
	path   []string
)

func partition(s string) [][]string {
	result, path = [][]string{}, []string{}
	backtracking(s, 0)
	return result
}

func backtracking(s string, startIndex int) {
	if startIndex >= len(s) {
		tmp := append([]string{}, path...)
		result = append(result, tmp)
		return
	}
	for i := startIndex; i < len(s); i++ {
		if isPalindrome(s, startIndex, i) {
			path = append(path, s[startIndex:i+1])
			backtracking(s, i+1)
			path = path[:len(path)-1]
		}
	}
}

func isPalindrome(s string, start, end int) bool {
	for i, j := start, end; i < j; i, j = i+1, j-1 {
		if s[i] != s[j] {
			return false
		}
	}
	return true
}
```
[reference]: https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.md
[131. Palindrome Partitioning]: https://leetcode.com/problems/palindromic-substrings/