---
Category: Hash
Subcategory: Hash
Title: 966. Vowel Spellchecker
Date: 2025-09-14
Difficulty: Medium
Status: Accepted
---

### [966. Vowel Spellchecker]

[966. Vowel Spellchecker](https://leetcode.com/problems/vowel-spellchecker/description)

這題的難點其實應該在理解題意，原本題目會給予兩個 wordlist 和 queries，然後要依照以下的規則來找出對應的字:

1.  如果 queries 裡的字在 wordlist 裡面有完全相同的字，直接回傳這個字
2.  如果 queries 裡的字在 wordlist 裡面有大小寫不同的字，回傳這個字
    -   queries: "KiTe", wordlist: "kite" -> "kite"
3.  如果 queries 裡的字在 wordlist 裡面有因為母音不同而導致的字，回傳這個字
    -   queries: "keto", wordlist: "kite" -> "kite"

在規則 2 和 3 裡面，如果有多個符合的字，回傳最早出現的字。

---

### Hash Map

所以重點其實在建立三個 Hash Map:

1.  完全相同的字
2.  大小寫不同的字
3.  母音不同的字

後面兩個 HashMap 的 Value 都使用 wordlist 裡面最早出現的字，這樣就能符合題目的要求。

建立好後把 queries 裡的字依照規則去三個 HashMap 裡面找就能得到答案，沒查到就給空字串。

Time Complexity: O(m + n), Space Complexity O(3 * m) = O(m).
-   m is the length of wordlist, n is the length of queries.

**Golang Solution:**
```go
var (
    wordMap map[string]string
    caseMap map[string]string
    vowelMap map[string]string
)

func spellchecker(wordlist []string, queries []string) []string {
    initMap(wordlist)

    res := []string{}

    for _, w := range queries {
        tmp := ""
        if value, ok := wordMap[w]; ok {
            tmp = value
        } else if value, ok := caseMap[strings.ToLower(w)]; ok {
            tmp = value
        } else if value, ok := vowelMap[toDevowel(strings.ToLower(w))]; ok {
            tmp = value
        }
        res = append(res, tmp)
    }

    return res
}

func initMap(wordlist []string) {
    wordMap = make(map[string]string)
    caseMap = make(map[string]string)
    vowelMap = make(map[string]string)

    for _, w := range wordlist {
        wordMap[w] = w
    }

    for _, w := range wordlist {
        lower := strings.ToLower(w)
        devowel := toDevowel(lower)

        if _, ok := caseMap[lower]; !ok {
            caseMap[lower] = w
        }
        if _, ok := vowelMap[devowel]; !ok {
            vowelMap[devowel] = w
        }
    }
}

func toDevowel(s string) string {
    result := make([]rune, 0, len(s))
    for _, r := range s {
        switch r {
        case 'a','e','i','o','u':
            result = append(result, '*')
        default:
            result = append(result, r)
        }
    }
    return string(result)
}
```